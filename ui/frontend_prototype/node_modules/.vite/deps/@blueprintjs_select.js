import {
  AbstractComponent,
  AbstractPureComponent,
  Button,
  Cross,
  DISPLAYNAME_PREFIX,
  InputGroup,
  Menu,
  Overlay,
  Popover,
  PopupKind,
  Search,
  TagInput,
  classes_exports,
  mergeRefs,
  refHandler,
  require_classnames,
  setRef,
  utils_exports
} from "./chunk-VOXPF6TS.js";
import "./chunk-3M3UOE3R.js";
import "./chunk-QYOLVIMM.js";
import "./chunk-4Y5A6CRR.js";
import "./chunk-INOU3XGQ.js";
import {
  __assign,
  __extends,
  __rest
} from "./chunk-YAVANF73.js";
import "./chunk-2C6EQPGN.js";
import "./chunk-JVZJ6C2S.js";
import "./chunk-7IBAJRJI.js";
import "./chunk-FIXOQDPZ.js";
import "./chunk-DJDQPSEU.js";
import {
  require_react
} from "./chunk-7GYLKDXG.js";
import {
  __export,
  __toESM
} from "./chunk-TITDT5VP.js";

// node_modules/@blueprintjs/select/lib/esm/common/classes.js
var classes_exports2 = {};
__export(classes_exports2, {
  MULTISELECT: () => MULTISELECT,
  MULTISELECT_POPOVER: () => MULTISELECT_POPOVER,
  MULTISELECT_TAG_INPUT_INPUT: () => MULTISELECT_TAG_INPUT_INPUT,
  OMNIBAR: () => OMNIBAR,
  OMNIBAR_OVERLAY: () => OMNIBAR_OVERLAY,
  SELECT_POPOVER: () => SELECT_POPOVER,
  SUGGEST_POPOVER: () => SUGGEST_POPOVER
});
var NS = classes_exports.getClassNamespace();
var MULTISELECT = "".concat(NS, "-multi-select");
var MULTISELECT_POPOVER = "".concat(MULTISELECT, "-popover");
var MULTISELECT_TAG_INPUT_INPUT = "".concat(MULTISELECT, "-tag-input-input");
var OMNIBAR = "".concat(NS, "-omnibar");
var OMNIBAR_OVERLAY = "".concat(OMNIBAR, "-overlay");
var SELECT_POPOVER = "".concat(NS, "-select-popover");
var SUGGEST_POPOVER = "".concat(NS, "-suggest-popover");

// node_modules/@blueprintjs/select/lib/esm/common/itemListRenderer.js
function renderFilteredItems(props, noResults, initialContent) {
  if (props.query.length === 0 && initialContent !== void 0) {
    return initialContent;
  }
  var items = props.filteredItems.map(props.renderItem).filter(function(item) {
    return item != null;
  });
  return items.length > 0 ? items : noResults;
}

// node_modules/@blueprintjs/select/lib/esm/common/listItemsProps.js
function executeItemsEqual(itemsEqualProp, itemA, itemB) {
  if (itemsEqualProp === void 0 || itemA == null || itemB == null) {
    return itemA === itemB;
  }
  if (utils_exports.isFunction(itemsEqualProp)) {
    return itemsEqualProp(itemA, itemB);
  } else {
    return itemA[itemsEqualProp] === itemB[itemsEqualProp];
  }
}

// node_modules/@blueprintjs/select/lib/esm/common/listItemsUtils.js
function getCreateNewItem() {
  return { __blueprintCreateNewItemBrand: "blueprint-create-new-item" };
}
function isCreateNewItem(item) {
  if (item == null) {
    return false;
  }
  var keys = Object.keys(item);
  if (keys.length !== 1 || keys[0] !== "__blueprintCreateNewItemBrand") {
    return false;
  }
  return item.__blueprintCreateNewItemBrand === "blueprint-create-new-item";
}
function getActiveItem(activeItem) {
  return activeItem == null || isCreateNewItem(activeItem) ? null : activeItem;
}

// node_modules/@blueprintjs/select/lib/esm/components/multi-select/multiSelect.js
var import_classnames = __toESM(require_classnames());
var React2 = __toESM(require_react());

// node_modules/@blueprintjs/select/lib/esm/components/query-list/queryList.js
var React = __toESM(require_react());
var QueryList = (
  /** @class */
  function(_super) {
    __extends(QueryList2, _super);
    function QueryList2(props) {
      var _a, _b;
      var _this = _super.call(this, props) || this;
      _this.itemRefs = /* @__PURE__ */ new Map();
      _this.refHandlers = {
        itemsParent: function(ref) {
          return _this.itemsParentRef = ref;
        }
      };
      _this.shouldCheckActiveItemInViewport = false;
      _this.expectedNextActiveItem = null;
      _this.isEnterKeyPressed = false;
      _this.renderItemList = function(listProps) {
        var _a2 = _this.props, initialContent = _a2.initialContent, noResults = _a2.noResults;
        var createItemView = listProps.renderCreateItem();
        var maybeNoResults = createItemView != null ? null : noResults;
        var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);
        if (menuContent == null && createItemView == null) {
          return null;
        }
        var createFirst = _this.isCreateItemFirst();
        return React.createElement(
          Menu,
          __assign({ role: "listbox" }, listProps.menuProps, { ulRef: listProps.itemsParentRef }),
          createFirst && createItemView,
          menuContent,
          !createFirst && createItemView
        );
      };
      _this.renderItem = function(item, index) {
        if (_this.props.disabled !== true) {
          var _a2 = _this.state, activeItem = _a2.activeItem, query2 = _a2.query, filteredItems2 = _a2.filteredItems;
          var modifiers = {
            active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),
            disabled: isItemDisabled(item, index, _this.props.itemDisabled),
            matchesPredicate: filteredItems2.indexOf(item) >= 0
          };
          return _this.props.itemRenderer(item, {
            handleClick: function(e) {
              return _this.handleItemSelect(item, e);
            },
            handleFocus: function() {
              return _this.setActiveItem(item);
            },
            index,
            modifiers,
            query: query2,
            ref: function(node) {
              if (node) {
                _this.itemRefs.set(index, node);
              } else {
                _this.itemRefs.delete(index);
              }
            }
          });
        }
        return null;
      };
      _this.renderCreateItemMenuItem = function() {
        if (_this.isCreateItemRendered(_this.state.createNewItem)) {
          var _a2 = _this.state, activeItem = _a2.activeItem, query2 = _a2.query;
          var trimmedQuery_1 = query2.trim();
          var handleClick = function(evt) {
            _this.handleItemCreate(trimmedQuery_1, evt);
          };
          var isActive = isCreateNewItem(activeItem);
          return _this.props.createNewItemRenderer(trimmedQuery_1, isActive, handleClick);
        }
        return null;
      };
      _this.handleItemCreate = function(query2, evt) {
        var _a2, _b2, _c2, _d;
        var value = (_b2 = (_a2 = _this.props).createNewItemFromQuery) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, query2);
        if (value != null) {
          var newItems = Array.isArray(value) ? value : [value];
          for (var _i = 0, newItems_1 = newItems; _i < newItems_1.length; _i++) {
            var item = newItems_1[_i];
            (_d = (_c2 = _this.props).onItemSelect) === null || _d === void 0 ? void 0 : _d.call(_c2, item, evt);
          }
          _this.maybeResetQuery();
        }
      };
      _this.handleItemSelect = function(item, event) {
        var _a2, _b2;
        _this.setActiveItem(item);
        (_b2 = (_a2 = _this.props).onItemSelect) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, item, event);
        _this.maybeResetQuery();
      };
      _this.handlePaste = function(queries) {
        var _a2 = _this.props, createNewItemFromQuery = _a2.createNewItemFromQuery, onItemsPaste = _a2.onItemsPaste;
        var nextActiveItem;
        var nextQueries = [];
        var pastedItemsToEmit = [];
        for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {
          var query2 = queries_1[_i];
          var equalItem = getMatchingItem(query2, _this.props);
          if (equalItem !== void 0) {
            nextActiveItem = equalItem;
            pastedItemsToEmit.push(equalItem);
          } else if (_this.canCreateItems()) {
            var value = createNewItemFromQuery === null || createNewItemFromQuery === void 0 ? void 0 : createNewItemFromQuery(query2);
            if (value !== void 0) {
              var newItems = Array.isArray(value) ? value : [value];
              pastedItemsToEmit.push.apply(pastedItemsToEmit, newItems);
            }
          } else {
            nextQueries.push(query2);
          }
        }
        _this.setQuery(nextQueries.join(", "), false);
        if (nextActiveItem !== void 0) {
          _this.setActiveItem(nextActiveItem);
        }
        onItemsPaste === null || onItemsPaste === void 0 ? void 0 : onItemsPaste(pastedItemsToEmit);
      };
      _this.handleKeyDown = function(event) {
        var _a2, _b2;
        var key = event.key;
        if (key === "ArrowUp" || key === "ArrowDown") {
          event.preventDefault();
          var nextActiveItem = _this.getNextActiveItem(key === "ArrowUp" ? -1 : 1);
          if (nextActiveItem != null) {
            _this.setActiveItem(nextActiveItem);
          }
        } else if (key === "Enter") {
          _this.isEnterKeyPressed = true;
        }
        (_b2 = (_a2 = _this.props).onKeyDown) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event);
      };
      _this.handleKeyUp = function(event) {
        var onKeyUp = _this.props.onKeyUp;
        var activeItem = _this.state.activeItem;
        if (event.key === "Enter" && _this.isEnterKeyPressed) {
          event.preventDefault();
          if (activeItem == null || isCreateNewItem(activeItem)) {
            _this.handleItemCreate(_this.state.query, event);
          } else {
            _this.handleItemSelect(activeItem, event);
          }
          _this.isEnterKeyPressed = false;
        }
        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);
      };
      _this.handleInputQueryChange = function(event) {
        var _a2, _b2;
        var query2 = event == null ? "" : event.target.value;
        _this.setQuery(query2);
        (_b2 = (_a2 = _this.props).onQueryChange) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, query2, event);
      };
      var _c = props.query, query = _c === void 0 ? "" : _c;
      var createNewItem = (_a = props.createNewItemFromQuery) === null || _a === void 0 ? void 0 : _a.call(props, query);
      var filteredItems = getFilteredItems(query, props);
      _this.state = {
        activeItem: props.activeItem !== void 0 ? props.activeItem : (_b = props.initialActiveItem) !== null && _b !== void 0 ? _b : getFirstEnabledItem(filteredItems, props.itemDisabled),
        createNewItem,
        filteredItems,
        query
      };
      return _this;
    }
    QueryList2.ofType = function() {
      return QueryList2;
    };
    QueryList2.prototype.render = function() {
      var _a = this.props, className = _a.className, items = _a.items, renderer = _a.renderer, _b = _a.itemListRenderer, itemListRenderer = _b === void 0 ? this.renderItemList : _b, menuProps = _a.menuProps;
      var _c = this.state, createNewItem = _c.createNewItem, spreadableState = __rest(_c, ["createNewItem"]);
      return renderer(__assign(__assign({}, spreadableState), { className, handleItemSelect: this.handleItemSelect, handleKeyDown: this.handleKeyDown, handleKeyUp: this.handleKeyUp, handlePaste: this.handlePaste, handleQueryChange: this.handleInputQueryChange, itemList: itemListRenderer(__assign(__assign({}, spreadableState), { items, itemsParentRef: this.refHandlers.itemsParent, menuProps, renderCreateItem: this.renderCreateItemMenuItem, renderItem: this.renderItem })) }));
    };
    QueryList2.prototype.componentDidUpdate = function(prevProps) {
      var _this = this;
      if (this.props.activeItem !== void 0 && this.props.activeItem !== this.state.activeItem) {
        this.shouldCheckActiveItemInViewport = true;
        this.setState({ activeItem: this.props.activeItem });
      }
      if (this.props.query != null && this.props.query !== prevProps.query) {
        this.setQuery(this.props.query, this.props.resetOnQuery, this.props);
      } else if (
        // same query (or uncontrolled query), but items in the list changed
        !utils_exports.shallowCompareKeys(this.props, prevProps, {
          include: ["items", "itemListPredicate", "itemPredicate"]
        })
      ) {
        this.setQuery(this.state.query);
      }
      if (this.shouldCheckActiveItemInViewport) {
        this.requestAnimationFrame(function() {
          return _this.scrollActiveItemIntoView();
        });
        this.shouldCheckActiveItemInViewport = false;
      }
    };
    QueryList2.prototype.scrollActiveItemIntoView = function() {
      var scrollToActiveItem = this.props.scrollToActiveItem !== false;
      var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));
      this.expectedNextActiveItem = null;
      if (!scrollToActiveItem && externalChangeToActiveItem) {
        return;
      }
      var activeElement = this.getActiveElement();
      if (this.itemsParentRef != null && activeElement != null) {
        var activeTop = activeElement.offsetTop, activeHeight = activeElement.offsetHeight;
        var _a = this.itemsParentRef, parentOffsetTop = _a.offsetTop, parentScrollTop = _a.scrollTop, parentHeight = _a.clientHeight;
        var _b = this.getItemsParentPadding(), paddingTop = _b.paddingTop, paddingBottom = _b.paddingBottom;
        var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;
        var activeTopEdge = activeTop - paddingTop - parentOffsetTop;
        if (activeBottomEdge >= parentScrollTop + parentHeight) {
          this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;
        } else if (activeTopEdge <= parentScrollTop) {
          this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;
        }
      }
    };
    QueryList2.prototype.setQuery = function(query, resetActiveItem, props) {
      var _a;
      if (resetActiveItem === void 0) {
        resetActiveItem = this.props.resetOnQuery;
      }
      if (props === void 0) {
        props = this.props;
      }
      var createNewItemFromQuery = props.createNewItemFromQuery;
      this.shouldCheckActiveItemInViewport = true;
      var hasQueryChanged = query !== this.state.query;
      if (hasQueryChanged) {
        (_a = props.onQueryChange) === null || _a === void 0 ? void 0 : _a.call(props, query);
      }
      var trimmedQuery = query.trim();
      var filteredItems = getFilteredItems(trimmedQuery, props);
      var createNewItem = createNewItemFromQuery != null && trimmedQuery !== "" ? createNewItemFromQuery(trimmedQuery) : void 0;
      this.setState({ createNewItem, filteredItems, query });
      var activeIndex = this.getActiveIndex(filteredItems);
      var shouldUpdateActiveItem = resetActiveItem || activeIndex < 0 || isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);
      if (shouldUpdateActiveItem) {
        if (this.isCreateItemRendered(createNewItem) && this.isCreateItemFirst()) {
          this.setActiveItem(getCreateNewItem());
        } else {
          this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));
        }
      }
    };
    QueryList2.prototype.setActiveItem = function(activeItem) {
      var _a, _b, _c, _d;
      this.expectedNextActiveItem = activeItem;
      if (this.props.activeItem === void 0) {
        this.shouldCheckActiveItemInViewport = true;
        this.setState({ activeItem });
      }
      if (isCreateNewItem(activeItem)) {
        (_b = (_a = this.props).onActiveItemChange) === null || _b === void 0 ? void 0 : _b.call(_a, null, true);
      } else {
        (_d = (_c = this.props).onActiveItemChange) === null || _d === void 0 ? void 0 : _d.call(_c, activeItem, false);
      }
    };
    QueryList2.prototype.getActiveElement = function() {
      var _a;
      var activeItem = this.state.activeItem;
      if (this.itemsParentRef != null) {
        if (isCreateNewItem(activeItem)) {
          var index = this.isCreateItemFirst() ? 0 : this.state.filteredItems.length;
          return this.itemsParentRef.children.item(index);
        } else {
          var activeIndex = this.getActiveIndex();
          return (_a = this.itemRefs.get(activeIndex)) !== null && _a !== void 0 ? _a : this.itemsParentRef.children.item(activeIndex);
        }
      }
      return void 0;
    };
    QueryList2.prototype.getActiveIndex = function(items) {
      if (items === void 0) {
        items = this.state.filteredItems;
      }
      var activeItem = this.state.activeItem;
      if (activeItem == null || isCreateNewItem(activeItem)) {
        return -1;
      }
      for (var i = 0; i < items.length; ++i) {
        if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {
          return i;
        }
      }
      return -1;
    };
    QueryList2.prototype.getItemsParentPadding = function() {
      var _a = getComputedStyle(this.itemsParentRef), paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
      return {
        paddingBottom: pxToNumber(paddingBottom),
        paddingTop: pxToNumber(paddingTop)
      };
    };
    QueryList2.prototype.getNextActiveItem = function(direction, startIndex) {
      if (startIndex === void 0) {
        startIndex = this.getActiveIndex();
      }
      if (this.isCreateItemRendered(this.state.createNewItem)) {
        var reachedCreate = startIndex === 0 && direction === -1 || startIndex === this.state.filteredItems.length - 1 && direction === 1;
        if (reachedCreate) {
          return getCreateNewItem();
        }
      }
      return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);
    };
    QueryList2.prototype.isCreateItemRendered = function(createNewItem) {
      return this.canCreateItems() && this.state.query !== "" && // this check is unfortunately O(N) on the number of items, but
      // alas, hiding the "Create Item" option when it exactly matches an
      // existing item is much clearer.
      !this.wouldCreatedItemMatchSomeExistingItem(createNewItem);
    };
    QueryList2.prototype.isCreateItemFirst = function() {
      return this.props.createNewItemPosition === "first";
    };
    QueryList2.prototype.canCreateItems = function() {
      return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;
    };
    QueryList2.prototype.wouldCreatedItemMatchSomeExistingItem = function(createNewItem) {
      var _this = this;
      return this.state.filteredItems.some(function(item) {
        var newItems = Array.isArray(createNewItem) ? createNewItem : [createNewItem];
        return newItems.some(function(newItem) {
          return executeItemsEqual(_this.props.itemsEqual, item, newItem);
        });
      });
    };
    QueryList2.prototype.maybeResetQuery = function() {
      if (this.props.resetOnSelect) {
        this.setQuery("", true);
      }
    };
    QueryList2.displayName = "".concat(DISPLAYNAME_PREFIX, ".QueryList");
    QueryList2.defaultProps = {
      disabled: false,
      resetOnQuery: true
    };
    return QueryList2;
  }(AbstractComponent)
);
function pxToNumber(value) {
  return value == null ? 0 : parseInt(value.slice(0, -2), 10);
}
function getMatchingItem(query, _a) {
  var items = _a.items, itemPredicate = _a.itemPredicate;
  if (utils_exports.isFunction(itemPredicate)) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (itemPredicate(query, item, i, true)) {
        return item;
      }
    }
  }
  return void 0;
}
function getFilteredItems(query, _a) {
  var items = _a.items, itemPredicate = _a.itemPredicate, itemListPredicate = _a.itemListPredicate;
  if (utils_exports.isFunction(itemListPredicate)) {
    return itemListPredicate(query, items);
  } else if (utils_exports.isFunction(itemPredicate)) {
    return items.filter(function(item, index) {
      return itemPredicate(query, item, index);
    });
  }
  return items;
}
function wrapNumber(value, min, max) {
  if (value < min) {
    return max;
  } else if (value > max) {
    return min;
  }
  return value;
}
function isItemDisabled(item, index, itemDisabled) {
  if (itemDisabled == null || item == null) {
    return false;
  } else if (utils_exports.isFunction(itemDisabled)) {
    return itemDisabled(item, index);
  }
  return !!item[itemDisabled];
}
function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {
  if (direction === void 0) {
    direction = 1;
  }
  if (startIndex === void 0) {
    startIndex = items.length - 1;
  }
  if (items.length === 0) {
    return null;
  }
  var index = startIndex;
  var maxIndex = items.length - 1;
  do {
    index = wrapNumber(index + direction, 0, maxIndex);
    if (!isItemDisabled(items[index], index, itemDisabled)) {
      return items[index];
    }
  } while (index !== startIndex && startIndex !== -1);
  return null;
}

// node_modules/@blueprintjs/select/lib/esm/components/multi-select/multiSelect.js
var MultiSelect = (
  /** @class */
  function(_super) {
    __extends(MultiSelect2, _super);
    function MultiSelect2() {
      var _a;
      var _this = _super.apply(this, arguments) || this;
      _this.listboxId = utils_exports.uniqueId("listbox");
      _this.state = {
        isOpen: _this.props.popoverProps && _this.props.popoverProps.isOpen || false
      };
      _this.input = null;
      _this.queryList = null;
      _this.refHandlers = {
        input: refHandler(_this, "input", (_a = _this.props.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputRef),
        popover: React2.createRef(),
        queryList: function(ref) {
          return _this.queryList = ref;
        }
      };
      _this.renderQueryList = function(listProps) {
        var _a2 = _this.props, disabled = _a2.disabled, _b = _a2.popoverContentProps, popoverContentProps = _b === void 0 ? {} : _b, _c = _a2.popoverProps, popoverProps = _c === void 0 ? {} : _c;
        var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
        var popoverRef = _this.props.popoverRef === void 0 ? _this.refHandlers.popover : mergeRefs(_this.refHandlers.popover, _this.props.popoverRef);
        return React2.createElement(Popover, __assign({ autoFocus: false, canEscapeKeyClose: true, disabled, enforceFocus: false, isOpen: _this.state.isOpen, placement: popoverProps.position || popoverProps.placement ? void 0 : "bottom-start" }, popoverProps, { className: (0, import_classnames.default)(listProps.className, popoverProps.className), content: React2.createElement("div", __assign({}, popoverContentProps, { onKeyDown: handleKeyDown, onKeyUp: handleKeyUp }), listProps.itemList), interactionKind: "click", onInteraction: _this.handlePopoverInteraction, onOpened: _this.handlePopoverOpened, popoverClassName: (0, import_classnames.default)(classes_exports2.MULTISELECT_POPOVER, popoverProps.popoverClassName), popupKind: PopupKind.LISTBOX, ref: popoverRef, renderTarget: _this.getPopoverTargetRenderer(listProps, _this.state.isOpen) }));
      };
      _this.getPopoverTargetRenderer = function(listProps, isOpen) {
        return function(_a2) {
          var _b;
          var _c;
          var _isOpen = _a2.isOpen, ref = _a2.ref, targetProps = __rest(_a2, ["isOpen", "ref"]);
          var _d = _this.props, disabled = _d.disabled, fill = _d.fill, onClear = _d.onClear, placeholder = _d.placeholder, _e = _d.popoverProps, popoverProps = _e === void 0 ? {} : _e, _f = _d.popoverTargetProps, popoverTargetProps = _f === void 0 ? {} : _f, selectedItems = _d.selectedItems, _g = _d.tagInputProps, tagInputProps = _g === void 0 ? {} : _g;
          var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
          var inputProps = __assign(__assign({}, tagInputProps.inputProps), { className: (0, import_classnames.default)((_c = tagInputProps.inputProps) === null || _c === void 0 ? void 0 : _c.className, classes_exports2.MULTISELECT_TAG_INPUT_INPUT) });
          var maybeClearButton = onClear !== void 0 && selectedItems.length > 0 ? (
            // use both aria-label and title a11y attributes here, for screen readers
            // and mouseover interactions respectively
            React2.createElement(Button, { "aria-label": "Clear selected items", disabled, icon: React2.createElement(Cross, null), minimal: true, onClick: _this.handleClearButtonClick, title: "Clear selected items" })
          ) : void 0;
          var _h = popoverProps.targetTagName, targetTagName = _h === void 0 ? "div" : _h;
          return React2.createElement(targetTagName, __assign(__assign(__assign({ "aria-autocomplete": "list", "aria-controls": _this.listboxId }, popoverTargetProps), targetProps), {
            "aria-disabled": disabled,
            "aria-expanded": isOpen,
            // Note that we must set FILL here in addition to TagInput to get the wrapper element to full width
            className: (0, import_classnames.default)(targetProps.className, popoverTargetProps.className, (_b = {}, _b[classes_exports.FILL] = fill, _b)),
            // Normally, Popover would also need to attach its own `onKeyDown` handler via `targetProps`,
            // but in our case we fully manage that interaction and listen for key events to open/close
            // the popover, so we elide it from the DOM.
            onKeyDown: _this.getTagInputKeyDownHandler(handleKeyDown),
            onKeyUp: _this.getTagInputKeyUpHandler(handleKeyUp),
            ref,
            role: "combobox"
          }), React2.createElement(TagInput, __assign({ placeholder, rightElement: maybeClearButton }, tagInputProps, { className: (0, import_classnames.default)(classes_exports2.MULTISELECT, tagInputProps.className), disabled, fill, inputRef: _this.refHandlers.input, inputProps, inputValue: listProps.query, onAdd: _this.getTagInputAddHandler(listProps), onInputChange: listProps.handleQueryChange, onRemove: _this.handleTagRemove, values: selectedItems.map(_this.props.tagRenderer) })));
        };
      };
      _this.handleItemSelect = function(item, evt) {
        var _a2, _b, _c;
        if (_this.input != null) {
          _this.input.focus();
        }
        (_b = (_a2 = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a2, item, evt);
        (_c = _this.refHandlers.popover.current) === null || _c === void 0 ? void 0 : _c.reposition();
      };
      _this.handleQueryChange = function(query, evt) {
        var _a2, _b;
        _this.setState({ isOpen: query.length > 0 || !_this.props.openOnKeyDown });
        (_b = (_a2 = _this.props).onQueryChange) === null || _b === void 0 ? void 0 : _b.call(_a2, query, evt);
      };
      _this.handlePopoverInteraction = function(nextOpenState, evt) {
        return _this.requestAnimationFrame(function() {
          var _a2, _b;
          var isInputFocused = _this.input === utils_exports.getActiveElement(_this.input);
          if (_this.input != null && !isInputFocused) {
            _this.setState({ isOpen: false });
          } else if (!_this.props.openOnKeyDown) {
            _this.setState({ isOpen: true });
          }
          (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a2, nextOpenState, evt);
        });
      };
      _this.handlePopoverOpened = function(node) {
        var _a2, _b;
        if (_this.queryList != null) {
          _this.queryList.scrollActiveItemIntoView();
        }
        (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onOpened) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
      };
      _this.handleTagRemove = function(tag, index) {
        var _a2, _b;
        var _c = _this.props, selectedItems = _c.selectedItems, onRemove = _c.onRemove, tagInputProps = _c.tagInputProps;
        onRemove === null || onRemove === void 0 ? void 0 : onRemove(selectedItems[index], index);
        (_a2 = tagInputProps === null || tagInputProps === void 0 ? void 0 : tagInputProps.onRemove) === null || _a2 === void 0 ? void 0 : _a2.call(tagInputProps, tag, index);
        (_b = _this.refHandlers.popover.current) === null || _b === void 0 ? void 0 : _b.reposition();
      };
      _this.getTagInputAddHandler = function(listProps) {
        return function(values, method) {
          if (method === "paste") {
            listProps.handlePaste(values);
          }
        };
      };
      _this.getTagInputKeyDownHandler = function(handleQueryListKeyDown) {
        return function(e) {
          var _a2, _b;
          if (e.key === "Escape" || e.key === "Tab") {
            if (_this.input != null) {
              _this.input.blur();
            }
            _this.setState({ isOpen: false });
          } else if (!(e.key === "Backspace" || e.key === "ArrowLeft" || e.key === "ArrowRight")) {
            _this.setState({ isOpen: true });
          }
          var isTargetingTagRemoveButton = e.target.closest(".".concat(classes_exports.TAG_REMOVE)) != null;
          if (_this.state.isOpen && !isTargetingTagRemoveButton) {
            handleQueryListKeyDown === null || handleQueryListKeyDown === void 0 ? void 0 : handleQueryListKeyDown(e);
          }
          (_b = (_a2 = _this.props.popoverTargetProps) === null || _a2 === void 0 ? void 0 : _a2.onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, e);
        };
      };
      _this.getTagInputKeyUpHandler = function(handleQueryListKeyUp) {
        return function(e) {
          var _a2, _b;
          var isTargetingInput = e.target.classList.contains(classes_exports2.MULTISELECT_TAG_INPUT_INPUT);
          if (_this.state.isOpen && isTargetingInput) {
            handleQueryListKeyUp === null || handleQueryListKeyUp === void 0 ? void 0 : handleQueryListKeyUp(e);
          }
          (_b = (_a2 = _this.props.popoverTargetProps) === null || _a2 === void 0 ? void 0 : _a2.onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, e);
        };
      };
      _this.handleClearButtonClick = function() {
        var _a2, _b, _c;
        (_b = (_a2 = _this.props).onClear) === null || _b === void 0 ? void 0 : _b.call(_a2);
        (_c = _this.refHandlers.popover.current) === null || _c === void 0 ? void 0 : _c.reposition();
      };
      return _this;
    }
    MultiSelect2.ofType = function() {
      return MultiSelect2;
    };
    MultiSelect2.prototype.componentDidUpdate = function(prevProps) {
      var _a, _b, _c, _d, _e;
      if (((_a = prevProps.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.tagInputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {
        setRef((_c = prevProps.tagInputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);
        this.refHandlers.input = refHandler(this, "input", (_d = this.props.tagInputProps) === null || _d === void 0 ? void 0 : _d.inputRef);
        setRef((_e = this.props.tagInputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.input);
      }
      if (prevProps.onClear === void 0 && this.props.onClear !== void 0 || prevProps.onClear !== void 0 && this.props.onClear === void 0) {
        this.forceUpdate();
      }
    };
    MultiSelect2.prototype.render = function() {
      var _a = this.props, menuProps = _a.menuProps, openOnKeyDown = _a.openOnKeyDown, popoverProps = _a.popoverProps, tagInputProps = _a.tagInputProps, restProps = __rest(_a, ["menuProps", "openOnKeyDown", "popoverProps", "tagInputProps"]);
      return React2.createElement(QueryList, __assign({}, restProps, { menuProps: __assign(__assign({ "aria-label": "selectable options" }, menuProps), { "aria-multiselectable": true, id: this.listboxId }), onItemSelect: this.handleItemSelect, onQueryChange: this.handleQueryChange, ref: this.refHandlers.queryList, renderer: this.renderQueryList }));
    };
    MultiSelect2.displayName = "".concat(DISPLAYNAME_PREFIX, ".MultiSelect");
    MultiSelect2.defaultProps = {
      disabled: false,
      fill: false,
      placeholder: "Search..."
    };
    return MultiSelect2;
  }(AbstractPureComponent)
);

// node_modules/@blueprintjs/select/lib/esm/components/omnibar/omnibar.js
var import_classnames2 = __toESM(require_classnames());
var React3 = __toESM(require_react());
var Omnibar = (
  /** @class */
  function(_super) {
    __extends(Omnibar2, _super);
    function Omnibar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.renderQueryList = function(listProps) {
        var _a = _this.props, _b = _a.inputProps, inputProps = _b === void 0 ? {} : _b, isOpen = _a.isOpen, _c = _a.overlayProps, overlayProps = _c === void 0 ? {} : _c;
        var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
        var handlers = isOpen ? { onKeyDown: handleKeyDown, onKeyUp: handleKeyUp } : {};
        return React3.createElement(
          Overlay,
          __assign({ hasBackdrop: true }, overlayProps, { isOpen, className: (0, import_classnames2.default)(classes_exports2.OMNIBAR_OVERLAY, overlayProps.className), onClose: _this.handleOverlayClose }),
          React3.createElement(
            "div",
            __assign({ className: (0, import_classnames2.default)(classes_exports2.OMNIBAR, listProps.className) }, handlers),
            React3.createElement(InputGroup, __assign({ autoFocus: true, large: true, leftIcon: React3.createElement(Search, null), placeholder: "Search..." }, inputProps, { onChange: listProps.handleQueryChange, value: listProps.query })),
            listProps.itemList
          )
        );
      };
      _this.handleOverlayClose = function(event) {
        var _a, _b, _c, _d;
        (_b = (_a = _this.props.overlayProps) === null || _a === void 0 ? void 0 : _a.onClose) === null || _b === void 0 ? void 0 : _b.call(_a, event);
        (_d = (_c = _this.props).onClose) === null || _d === void 0 ? void 0 : _d.call(_c, event);
      };
      return _this;
    }
    Omnibar2.ofType = function() {
      return Omnibar2;
    };
    Omnibar2.prototype.render = function() {
      var _a = this.props, isOpen = _a.isOpen, inputProps = _a.inputProps, overlayProps = _a.overlayProps, restProps = __rest(_a, ["isOpen", "inputProps", "overlayProps"]);
      var initialContent = "initialContent" in this.props ? this.props.initialContent : null;
      return React3.createElement(QueryList, __assign({}, restProps, {
        // Omnibar typically does not keep track of and/or show its selection state like other
        // select components, so it's more of a menu than a listbox. This means that users should return
        // MenuItems with roleStructure="menuitem" (the default value) in `props.itemRenderer`.
        menuProps: { role: "menu" },
        initialContent,
        renderer: this.renderQueryList
      }));
    };
    Omnibar2.displayName = "".concat(DISPLAYNAME_PREFIX, ".Omnibar");
    return Omnibar2;
  }(React3.PureComponent)
);

// node_modules/@blueprintjs/select/lib/esm/components/select/select.js
var import_classnames3 = __toESM(require_classnames());
var React4 = __toESM(require_react());
var Select = (
  /** @class */
  function(_super) {
    __extends(Select2, _super);
    function Select2() {
      var _a;
      var _this = _super.apply(this, arguments) || this;
      _this.state = { isOpen: false };
      _this.inputElement = null;
      _this.queryList = null;
      _this.handleInputRef = refHandler(_this, "inputElement", (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef);
      _this.handleQueryListRef = function(ref) {
        return _this.queryList = ref;
      };
      _this.listboxId = utils_exports.uniqueId("listbox");
      _this.renderQueryList = function(listProps) {
        var _a2 = _this.props, _b = _a2.filterable, filterable = _b === void 0 ? true : _b, _c = _a2.disabled, disabled = _c === void 0 ? false : _c, _d = _a2.inputProps, inputProps = _d === void 0 ? {} : _d, _e = _a2.popoverContentProps, popoverContentProps = _e === void 0 ? {} : _e, _f = _a2.popoverProps, popoverProps = _f === void 0 ? {} : _f, popoverRef = _a2.popoverRef;
        var input = React4.createElement(InputGroup, __assign({ "aria-autocomplete": "list", leftIcon: React4.createElement(Search, null), placeholder: "Filter...", rightElement: _this.maybeRenderClearButton(listProps.query) }, inputProps, { inputRef: _this.handleInputRef, onChange: listProps.handleQueryChange, value: listProps.query }));
        var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
        return React4.createElement(Popover, __assign({ autoFocus: false, enforceFocus: false, isOpen: _this.state.isOpen, disabled, placement: popoverProps.position || popoverProps.placement ? void 0 : "bottom-start" }, popoverProps, { className: (0, import_classnames3.default)(listProps.className, popoverProps.className), content: React4.createElement(
          "div",
          __assign({}, popoverContentProps, { onKeyDown: handleKeyDown, onKeyUp: handleKeyUp }),
          filterable ? input : void 0,
          listProps.itemList
        ), onClosing: _this.handlePopoverClosing, onInteraction: _this.handlePopoverInteraction, onOpened: _this.handlePopoverOpened, onOpening: _this.handlePopoverOpening, popoverClassName: (0, import_classnames3.default)(classes_exports2.SELECT_POPOVER, popoverProps.popoverClassName), popupKind: PopupKind.LISTBOX, ref: popoverRef, renderTarget: _this.getPopoverTargetRenderer(listProps, _this.state.isOpen) }));
      };
      _this.getPopoverTargetRenderer = function(listProps, isOpen) {
        return function(_a2) {
          var _b;
          var _isOpen = _a2.isOpen, ref = _a2.ref, targetProps = __rest(_a2, ["isOpen", "ref"]);
          var _c = _this.props, disabled = _c.disabled, _d = _c.popoverProps, popoverProps = _d === void 0 ? {} : _d, popoverTargetProps = _c.popoverTargetProps;
          var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
          var _e = popoverProps.targetTagName, targetTagName = _e === void 0 ? "div" : _e;
          return React4.createElement(targetTagName, __assign(__assign(__assign({ "aria-controls": _this.listboxId }, popoverTargetProps), targetProps), {
            "aria-disabled": disabled,
            "aria-expanded": isOpen,
            // Note that we must set FILL here in addition to children to get the wrapper element to full width
            className: (0, import_classnames3.default)(targetProps.className, popoverTargetProps === null || popoverTargetProps === void 0 ? void 0 : popoverTargetProps.className, (_b = {}, _b[classes_exports.FILL] = _this.props.fill, _b)),
            // Normally, Popover would also need to attach its own `onKeyDown` handler via `targetProps`,
            // but in our case we fully manage that interaction and listen for key events to open/close
            // the popover, so we elide it from the DOM.
            onKeyDown: _this.withPopoverTargetPropsHandler("keydown", isOpen ? handleKeyDown : _this.handleTargetKeyDown),
            onKeyUp: _this.withPopoverTargetPropsHandler("keyup", isOpen ? handleKeyUp : void 0),
            ref,
            role: "combobox"
          }), _this.props.children);
        };
      };
      _this.withPopoverTargetPropsHandler = function(eventType, handler) {
        switch (eventType) {
          case "keydown":
            return function(event) {
              var _a2, _b;
              handler === null || handler === void 0 ? void 0 : handler(event);
              (_b = (_a2 = _this.props.popoverTargetProps) === null || _a2 === void 0 ? void 0 : _a2.onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
            };
          case "keyup":
            return function(event) {
              var _a2, _b;
              handler === null || handler === void 0 ? void 0 : handler(event);
              (_b = (_a2 = _this.props.popoverTargetProps) === null || _a2 === void 0 ? void 0 : _a2.onKeyUp) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
            };
        }
      };
      _this.handleTargetKeyDown = function(event) {
        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
          event.preventDefault();
          _this.setState({ isOpen: true });
        } else if (utils_exports.isKeyboardClick(event)) {
          _this.setState({ isOpen: true });
        }
      };
      _this.handleItemSelect = function(item, event) {
        var _a2, _b;
        var target = event === null || event === void 0 ? void 0 : event.target;
        var menuItem = target === null || target === void 0 ? void 0 : target.closest(".".concat(classes_exports.MENU_ITEM));
        var menuItemDismiss = menuItem === null || menuItem === void 0 ? void 0 : menuItem.matches(".".concat(classes_exports.POPOVER_DISMISS));
        var shouldDismiss = menuItemDismiss !== null && menuItemDismiss !== void 0 ? menuItemDismiss : true;
        _this.setState({ isOpen: !shouldDismiss });
        (_b = (_a2 = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a2, item, event);
      };
      _this.handlePopoverInteraction = function(isOpen, event) {
        var _a2, _b;
        _this.setState({ isOpen });
        (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a2, isOpen, event);
      };
      _this.handlePopoverOpening = function(node) {
        var _a2, _b, _c;
        _this.previousFocusedElement = (_a2 = utils_exports.getActiveElement(_this.inputElement)) !== null && _a2 !== void 0 ? _a2 : void 0;
        if (_this.props.resetOnClose) {
          _this.resetQuery();
        }
        (_c = (_b = _this.props.popoverProps) === null || _b === void 0 ? void 0 : _b.onOpening) === null || _c === void 0 ? void 0 : _c.call(_b, node);
      };
      _this.handlePopoverOpened = function(node) {
        var _a2, _b;
        if (_this.queryList != null) {
          _this.queryList.scrollActiveItemIntoView();
        }
        _this.requestAnimationFrame(function() {
          var _a3;
          var _b2 = _this.props.inputProps, inputProps = _b2 === void 0 ? {} : _b2;
          if (inputProps.autoFocus !== false) {
            (_a3 = _this.inputElement) === null || _a3 === void 0 ? void 0 : _a3.focus();
          }
        });
        (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onOpened) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
      };
      _this.handlePopoverClosing = function(node) {
        var _a2, _b;
        _this.requestAnimationFrame(function() {
          if (_this.previousFocusedElement !== void 0) {
            _this.previousFocusedElement.focus();
            _this.previousFocusedElement = void 0;
          }
        });
        (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onClosing) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
      };
      _this.resetQuery = function() {
        return _this.queryList && _this.queryList.setQuery("", true);
      };
      return _this;
    }
    Select2.ofType = function() {
      return Select2;
    };
    Select2.prototype.render = function() {
      var _a = this.props, filterable = _a.filterable, inputProps = _a.inputProps, menuProps = _a.menuProps, popoverProps = _a.popoverProps, restProps = __rest(_a, ["filterable", "inputProps", "menuProps", "popoverProps"]);
      return React4.createElement(QueryList, __assign({}, restProps, { menuProps: __assign(__assign({ "aria-label": "selectable options" }, menuProps), { id: this.listboxId }), onItemSelect: this.handleItemSelect, ref: this.handleQueryListRef, renderer: this.renderQueryList }));
    };
    Select2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var _a, _b, _c, _d, _e;
      if (((_a = prevProps.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.inputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {
        setRef((_c = prevProps.inputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);
        this.handleInputRef = refHandler(this, "inputElement", (_d = this.props.inputProps) === null || _d === void 0 ? void 0 : _d.inputRef);
        setRef((_e = this.props.inputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.inputElement);
      }
      if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {
        this.queryList.scrollActiveItemIntoView();
      }
    };
    Select2.prototype.maybeRenderClearButton = function(query) {
      return query.length > 0 ? React4.createElement(Button, { "aria-label": "Clear filter query", icon: React4.createElement(Cross, null), minimal: true, onClick: this.resetQuery, title: "Clear filter query" }) : void 0;
    };
    Select2.displayName = "".concat(DISPLAYNAME_PREFIX, ".Select");
    return Select2;
  }(AbstractPureComponent)
);

// node_modules/@blueprintjs/select/lib/esm/components/suggest/suggest.js
var import_classnames4 = __toESM(require_classnames());
var React5 = __toESM(require_react());
var Suggest = (
  /** @class */
  function(_super) {
    __extends(Suggest2, _super);
    function Suggest2() {
      var _a;
      var _this = _super.apply(this, arguments) || this;
      _this.state = {
        isOpen: _this.props.popoverProps != null && _this.props.popoverProps.isOpen || false,
        selectedItem: _this.getInitialSelectedItem()
      };
      _this.inputElement = null;
      _this.queryList = null;
      _this.handleInputRef = refHandler(_this, "inputElement", (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef);
      _this.handleQueryListRef = function(ref) {
        return _this.queryList = ref;
      };
      _this.listboxId = utils_exports.uniqueId("listbox");
      _this.renderQueryList = function(listProps) {
        var _a2 = _this.props, _b = _a2.popoverContentProps, popoverContentProps = _b === void 0 ? {} : _b, _c = _a2.popoverProps, popoverProps = _c === void 0 ? {} : _c, popoverRef = _a2.popoverRef;
        var isOpen = _this.state.isOpen;
        var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
        return React5.createElement(Popover, __assign({ autoFocus: false, enforceFocus: false, isOpen, placement: popoverProps.position || popoverProps.placement ? void 0 : "bottom-start" }, popoverProps, { className: (0, import_classnames4.default)(listProps.className, popoverProps.className), content: React5.createElement("div", __assign({}, popoverContentProps, { onKeyDown: handleKeyDown, onKeyUp: handleKeyUp }), listProps.itemList), interactionKind: "click", onInteraction: _this.handlePopoverInteraction, onOpened: _this.handlePopoverOpened, onOpening: _this.handlePopoverOpening, popoverClassName: (0, import_classnames4.default)(classes_exports2.SUGGEST_POPOVER, popoverProps.popoverClassName), popupKind: PopupKind.LISTBOX, ref: popoverRef, renderTarget: _this.getPopoverTargetRenderer(listProps, isOpen) }));
      };
      _this.getPopoverTargetRenderer = function(listProps, isOpen) {
        return function(_a2) {
          var _isOpen = _a2.isOpen, ref = _a2.ref, targetProps = __rest(_a2, ["isOpen", "ref"]);
          var _b = _this.props, disabled = _b.disabled, fill = _b.fill, _c = _b.inputProps, inputProps = _c === void 0 ? {} : _c, inputValueRenderer = _b.inputValueRenderer, _d = _b.popoverProps, popoverProps = _d === void 0 ? {} : _d, resetOnClose = _b.resetOnClose;
          var selectedItem = _this.state.selectedItem;
          var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
          var selectedItemText = selectedItem == null ? "" : inputValueRenderer(selectedItem);
          var _e = inputProps.autoComplete, autoComplete = _e === void 0 ? "off" : _e, _f = inputProps.placeholder, placeholder = _f === void 0 ? "Search..." : _f;
          var inputPlaceholder = isOpen && selectedItemText ? selectedItemText : placeholder;
          var inputValue = isOpen ? listProps.query : selectedItemText === "" ? resetOnClose ? "" : listProps.query : selectedItemText;
          return React5.createElement(InputGroup, __assign({ "aria-controls": _this.listboxId, autoComplete, disabled, tagName: popoverProps.targetTagName }, targetProps, inputProps, { "aria-autocomplete": "list", "aria-expanded": isOpen, className: (0, import_classnames4.default)(targetProps.className, inputProps.className), fill, inputRef: mergeRefs(_this.handleInputRef, ref), onChange: listProps.handleQueryChange, onFocus: _this.handleInputFocus, onKeyDown: _this.getTargetKeyDownHandler(handleKeyDown), onKeyUp: _this.getTargetKeyUpHandler(handleKeyUp), placeholder: inputPlaceholder, role: "combobox", value: inputValue }));
        };
      };
      _this.selectText = function() {
        _this.requestAnimationFrame(function() {
          var _a2;
          (_a2 = _this.inputElement) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(0, _this.inputElement.value.length);
        });
      };
      _this.handleInputFocus = function(event) {
        var _a2, _b;
        _this.selectText();
        if (!_this.props.openOnKeyDown) {
          _this.setState({ isOpen: true });
        }
        (_b = (_a2 = _this.props.inputProps) === null || _a2 === void 0 ? void 0 : _a2.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      };
      _this.handleItemSelect = function(item, event) {
        var _a2, _b, _c, _d;
        var nextOpenState;
        if (!_this.props.closeOnSelect) {
          (_a2 = _this.inputElement) === null || _a2 === void 0 ? void 0 : _a2.focus();
          _this.selectText();
          nextOpenState = true;
        } else {
          (_b = _this.inputElement) === null || _b === void 0 ? void 0 : _b.blur();
          nextOpenState = false;
        }
        if (_this.props.selectedItem === void 0) {
          _this.setState({
            isOpen: nextOpenState,
            selectedItem: item
          });
        } else {
          _this.setState({ isOpen: nextOpenState });
        }
        (_d = (_c = _this.props).onItemSelect) === null || _d === void 0 ? void 0 : _d.call(_c, item, event);
      };
      _this.handlePopoverInteraction = function(nextOpenState, event) {
        return _this.requestAnimationFrame(function() {
          var _a2, _b;
          var isInputFocused = _this.inputElement === utils_exports.getActiveElement(_this.inputElement);
          if (_this.inputElement != null && !isInputFocused) {
            _this.setState({ isOpen: false });
          }
          (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a2, nextOpenState, event);
        });
      };
      _this.handlePopoverOpening = function(node) {
        var _a2, _b;
        if (_this.props.resetOnClose && _this.queryList) {
          _this.queryList.setQuery("", true);
        }
        (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onOpening) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
      };
      _this.handlePopoverOpened = function(node) {
        var _a2, _b;
        if (_this.queryList != null) {
          _this.queryList.scrollActiveItemIntoView();
        }
        (_b = (_a2 = _this.props.popoverProps) === null || _a2 === void 0 ? void 0 : _a2.onOpened) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
      };
      _this.getTargetKeyDownHandler = function(handleQueryListKeyDown) {
        return function(e) {
          var _a2, _b, _c;
          if (e.key === "Escape" || e.key === "Tab") {
            (_a2 = _this.inputElement) === null || _a2 === void 0 ? void 0 : _a2.blur();
            _this.setState({ isOpen: false });
          } else if (_this.props.openOnKeyDown && e.key !== "Backspace" && e.key !== "ArrowLeft" && e.key !== "ArrowRight") {
            _this.setState({ isOpen: true });
          }
          if (_this.state.isOpen) {
            handleQueryListKeyDown === null || handleQueryListKeyDown === void 0 ? void 0 : handleQueryListKeyDown(e);
          }
          (_c = (_b = _this.props.inputProps) === null || _b === void 0 ? void 0 : _b.onKeyDown) === null || _c === void 0 ? void 0 : _c.call(_b, e);
        };
      };
      _this.getTargetKeyUpHandler = function(handleQueryListKeyUp) {
        return function(evt) {
          var _a2, _b;
          if (_this.state.isOpen) {
            handleQueryListKeyUp === null || handleQueryListKeyUp === void 0 ? void 0 : handleQueryListKeyUp(evt);
          }
          (_b = (_a2 = _this.props.inputProps) === null || _a2 === void 0 ? void 0 : _a2.onKeyUp) === null || _b === void 0 ? void 0 : _b.call(_a2, evt);
        };
      };
      return _this;
    }
    Suggest2.ofType = function() {
      return Suggest2;
    };
    Suggest2.prototype.render = function() {
      var _a;
      var _b = this.props, disabled = _b.disabled, inputProps = _b.inputProps, menuProps = _b.menuProps, popoverProps = _b.popoverProps, restProps = __rest(_b, ["disabled", "inputProps", "menuProps", "popoverProps"]);
      return React5.createElement(QueryList, __assign({}, restProps, { menuProps: __assign(__assign({ "aria-label": "selectable options" }, menuProps), { id: this.listboxId }), initialActiveItem: (_a = this.props.selectedItem) !== null && _a !== void 0 ? _a : void 0, onItemSelect: this.handleItemSelect, ref: this.handleQueryListRef, renderer: this.renderQueryList }));
    };
    Suggest2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var _this = this;
      var _a, _b, _c, _d, _e, _f, _g;
      if (((_a = prevProps.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.inputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {
        setRef((_c = prevProps.inputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);
        this.handleInputRef = refHandler(this, "inputElement", (_d = this.props.inputProps) === null || _d === void 0 ? void 0 : _d.inputRef);
        setRef((_e = this.props.inputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.inputElement);
      }
      if (this.props.selectedItem !== void 0 && this.props.selectedItem !== this.state.selectedItem) {
        this.setState({ selectedItem: this.props.selectedItem });
      }
      if (this.state.isOpen === false && prevState.isOpen === true) {
        var timeout = (_g = (_f = this.props.popoverProps) === null || _f === void 0 ? void 0 : _f.transitionDuration) !== null && _g !== void 0 ? _g : Popover.defaultProps.transitionDuration;
        setTimeout(function() {
          return _this.maybeResetActiveItemToSelectedItem();
        }, timeout);
      }
      if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {
        this.queryList.scrollActiveItemIntoView();
      }
    };
    Suggest2.prototype.getInitialSelectedItem = function() {
      if (this.props.selectedItem !== void 0) {
        return this.props.selectedItem;
      } else if (this.props.defaultSelectedItem !== void 0) {
        return this.props.defaultSelectedItem;
      } else {
        return null;
      }
    };
    Suggest2.prototype.maybeResetActiveItemToSelectedItem = function() {
      var _a;
      var shouldResetActiveItemToSelectedItem = this.props.activeItem === void 0 && this.state.selectedItem !== null && !this.props.resetOnSelect;
      if (this.queryList !== null && shouldResetActiveItemToSelectedItem) {
        this.queryList.setActiveItem((_a = this.props.selectedItem) !== null && _a !== void 0 ? _a : this.state.selectedItem);
      }
    };
    Suggest2.displayName = "".concat(DISPLAYNAME_PREFIX, ".Suggest");
    Suggest2.defaultProps = {
      closeOnSelect: true,
      fill: false,
      openOnKeyDown: false,
      resetOnClose: false
    };
    return Suggest2;
  }(AbstractPureComponent)
);
export {
  classes_exports2 as Classes,
  MultiSelect,
  MultiSelect as MultiSelect2,
  Omnibar,
  QueryList,
  Select,
  Select as Select2,
  Suggest,
  Suggest as Suggest2,
  executeItemsEqual,
  getActiveItem,
  getCreateNewItem,
  isCreateNewItem,
  renderFilteredItems
};
//# sourceMappingURL=@blueprintjs_select.js.map
