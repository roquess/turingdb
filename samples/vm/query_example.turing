.data
LABEL $1 "physical entity"
LABEL $2 "protein"
LABEL $3 "drug"
LABEL $4 "reaction"
LABEL $5 "cell"

LABELSET $protein {$1, $2, $3}
LABELSET $reaction {$4}
LABELSET $cell {$1, $5}

.alias
ALIAS %c r0

.text:

SCAN_OUT_EDGES i1 $protein
    JMP_VALID i1 i1_content i1_end # if i1 valid jmp to i1_content, else jmp to i1_end

    i1_step:
    NEXT_OR_JMP i1 i1_end # it.next(), if i1 == end(), jmp to i1_end

    i1_content:
    LABESET_COVERS $reaction i1.tgt # if $reaction label covers that of node i1.tgt set _zeroFlag
    JNE             i1_step

    # From here the tgt node has label reaction
    GET_OUT_EDGES i2 {_, _, _, r1, _, _}
        JMP_VALID i2 i2_content i2_end

        i2_step:
        NEXT_OR_JMP i2 i2_end

        i2_content:
        LABELSET_COVERS $cell i2.tgt
        JNE i2_step

        YIELD %c i2.tgt # write i2.tgt into %c register

        JMP i2_step
        i2_end:

    JMP i1_step
    i1_end:
EXIT



# Code of a for loop based on an iterator:
ITERATOR i1 ...
    JMP_VALID i1 i1_content i1_end

    i1_step:
    NEXT_OR_JM i1 i1_end

    i1_content:
    # Content goes here

    JMP i1_step
    i1_end:

# Example code of a filter
LABELSET_XXXX   %id $reaction
JNE             prev_step        #continue

# Filters:
LABELSET_COVERS  # if input labelset is covered by comparison labelset
LABELSET_EXCLUDE # if input labelset has none of the labels in comparison labelset
LABELSET_EQUAL   # if input labelset exactly matches comparison labelset

# At the most inner part of the program, YIELD


# The only hard part to generate the algorithm is 
# to set the appropriate instruction arguments
